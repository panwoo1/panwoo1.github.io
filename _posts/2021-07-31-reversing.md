---
title: "[모각코]해킹맛보기(리버스 엔지니어링 3.1 ~ 3.4)"
excerpt_separator: "<!--more-->"
toc: true
toc_sticky: true
categories:
  - 모각코
tags:
  - 모각코
  - Hacking
---

## 07-31 토요일

## 리버스 엔지니어링

### 개요

리버스 엔지니어링은 우리말로 역공학이라 불리며 제품, 도구를 분해해서 분석하거나 재조합하는 것  
이를 줄여서 **리버싱** 이라고도 함

개발과 리버싱에 필요한 기초 지식은 거의 동일하며, 각종 어셈블리어, 운영체제, 실행 파일 구조 등 학습해야 할 기초 지식이 방대함

### 사례

- **컴퓨터 원리와 구조 이해**

  리버싱을 위해서는 프로그램이 컴퓨터의 CPU, 레지스터, 메모리, 운영체제 등을 어떻게 사용해 실행되는지 알아야 함
  이를 리버싱을 통해 직접 보면서 딱딱한 기초 지식을 재미있게 습득할 수 있음

- **프로그램 유지보수**

  실무에서 사용 중인 프로그램의 유지보수를 위해 리버싱이 사용되며, 프로그램 사용 중에 발견되는 버그를 리버싱으로  
  쉽게 찾는 경우가 많으며, 소스 코드가 없는 프로그램도 리버싱을 이용해 유지보수 할 수 있음

- **개발에 활용**

  프로그램 리버싱을 통해 상호 호환이 되는 새로운 프로그램을 만들 수 있음 (ex. 컴팩의 IBM 바이오스 리버싱)  
  대한민국에서는 프로그램의 리버싱이 금지되어 있어서, 크랙 또는 복제의 목적으로 분석을 해서는 안됨

- **보안점검 및 취약점**

  버그는 계속해서 발생하고, 소스 코드가 없는 프로그램의 버그를 정확히 알기 위해서는 리버싱이 필요함  
  프로그램에서 취약한 알고리즘을 사용하거나 주요 정보를 평문으로 저장하고 있는 경우 등을 찾아냄으로써 리버싱으로 보안점검

- **악성코드 분석**

  악성코드는 소스 코드 없이 실행 파일만 배포되기 때문에 악성코드가  
  컴퓨터에 어떤 영향을 끼치는지를 분석해야 함  
  악성코드 분석을 위해서는 많은 리버싱 기술들이 필요함

### 환경

- Visual Stuido Express
- OllyDbg(리버싱을 위한 디버깅 툴)

### 기초 지식

- **CPU**

  CPU는 외부로부터 명령어를 입력바다 해석하고 연산해서 실행하는 역할  
  CPU 내부에서 작종 정보를 저장하기 위해 임시 기억 장치 레지스터를 사용하고, 레지스터 만으로는  
  저장할 수 있는 정보의 양이 적어 주기억 장치 휘발성 메모리 RAM을 사용하고,
  비휘발성 메모리인 보조기억 장치 하드 디스크나 SSD를 사용함

  ![CPU 관계또 (2)](https://user-images.githubusercontent.com/66258691/127726059-7e43da01-80dc-4cdf-985e-2f331dbf8630.jpg){: width="60%" height="60%"}{: .center}

- **레지스터**

  IA-32(인텔의 32비트 머아크로프로세서) 기준으로 8개의 32비트 범용 레지스터와 6개의 16비트 세그먼트 레지스터,  
  32비트 EFLAGS 레지스터, 32비트 EIP 레지스터를 가짐

- **메모리 구조**

  IA-32에서는 32비트(0 ~ 2^32 - 1) 크기만큼 메모리에 접근할 수 있음
  프로그램이 실행되면 각각의 세그먼트 단위로 묶어 메모리에 저장하며, 각각의 세그먼트는 코드 세그먼트, 스택 세그먼트, 데이터 세그먼트임

  - **코드 세그먼트** - 컴퓨터가 수행할 수 있는 명령어들이 저장되어 있는 메모리
  - **스택 세그먼트** - 현재 수행되고 있는 프로그램의 지역 변수와 함수 호출 인자를 저장하는 메모리 영역
  - **데이터 세그먼트** - 전역 변수와 힙을 저장하는 메모리 영역 (힙은 동적 메모리 공간)

- **컴파일, 디컴파일**

  바이너리 데이터로 이뤄진 실행 파일을 만들기 위해서는 컴파일 과정을 거쳐야함  
  리버싱은 컴파일 과정의 역순인 디컴파일 과정을 수행해야 함

  - 컴파일 과정(ex C)

    C, C++, Obejct-C => 컴파일러 => 어셈블리 코드 => 어셈블러 => 오브젝트 코드 => 링커 => 실행 파일

- **바이트 오더**

  바이트 오더 - 컴퓨터에서 데이터가 바이트 단위로 메모리에 저장되는 순서

  - 빅 인디안 - 사람이 숫자를 쓰는 방식과 같이 가장 큰 단위의 바이트가 앞에 옴
  - 리틀 인디안 - 반대로 작은 단위의 바이트가 앞에 옴

  ![바이트 오더 (2)](https://user-images.githubusercontent.com/66258691/127726372-e4d43295-dc0c-4851-85dd-097b2b9b7c47.jpg){: width="60%" height="60%"}{: .center}

- **디버깅**

  디버깅 - 컴퓨터 프로그램의 버그를 찾아서 제거하는 일련의 과정  
  올리디버거로 분석할 코드에 break point를 설정해 프로그램 실행을 중단하고 레지스터, 메모리에 저장된 값을  
  살펴보며 재실행하거나, 코드를 단계적으로 실행하는 과정으로 디버깅을 수행

### 올리디버거 실습

![올리디버거 실습](https://user-images.githubusercontent.com/66258691/127726741-342ceae1-a239-4467-8845-e2bfbab60e9b.png)

각각 왼쪽 위는 코드 영역, 오른쪽 위는 레지스터 영역, 왼쪽 아래는 덤프 영역, 오른쪽 아래는 스택 영역

#### 참고자료

- 해킹맛보기
