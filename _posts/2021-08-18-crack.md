---
title: "[모각코] Reversing(마무리)"
excerpt_separator: "<!--more-->"
toc: true
toc_sticky: true
categories:
  - 모각코
tags:
  - 모각코
  - Hacking
---

## 08-18

## crackme를 통한 디버거 사용법-1

### 예제

문제: 2개의 정수를 입력받아 값이 특정 조건을 만족하면 correct!을 출력하고   
틀리면 wrong!을 출력

**문제 풀이 - 0**

프로그램에서 `input: `을 출력하고, 숫자 2개를 입력받고, 무언가   
받은 숫자를 처리하는 코드를 실행한 다음, 그 결과에 따라   
`correct!`나 `wrong!`을 출력하는 순서로 실행됨

따라서 `main`함수에서 `printf`, `puts`등의 출력 함수 및   
`scanf`같이 입력을 받는 함수가 포함되었을 것임

**문제 풀이 - 1 메인함수 찾기**

x64dbg에서 모듈 간 호출 찾기 기능을 사용해 `main`함수를 찾음

**문제 풀이 - 2 메인함수 분석**

번호별로 다음과 같음

1. 스택을 확장하는 코드, 이 함수에서 스택을 0x38만큼 스택을   
사용한다는 것을 알 수 있음

2. 첫 번째 인자에 `input:` 문자열의 주소를 넣고 `sub_140001070`함수 호출   
내부로 들어가 분석할 수 있지만, 이 프로그램에서는 인자만으로   
`printf`이거나 이와 비슷한 함수라는 것을 알 수 있어 넘어가도 됨

-> 이처럼 적당히 추측하고 넘어가는 것이 분석 시간을 단축하는 데 있어   
중요한 요소 중 하나

3. 첫 번째 인자에 `%d %d`문자열의 주소를 넣고, 두 번째 인자에 `rsp+0x14`   
세 번째 인자에 `rsp+0x20`을 넣고 `sub_140001120`을 호출

4. 첫 번째 인자에 `rsp+0x24`, 두 번째 인자에 `rsp+0x20`을 넣고        
`sub_140001180`를 호출

5. `sub_140001180`함수의 리턴값인 `eax`를 확인해 0이면 점프를 뛰어   
`wrong!`이 출력되고 1이면 점프를 뛰지 않고 `correct!`을 출력

6. `main`함수의 리턴값을 0으로 설정하고 확장한 스택을 정리한 후 리턴

```
1|140001200 | sub rsp,38                         |
2|140001204 | lea rcx,qword ptr ds:[140002230]   | 140002230:"input: "
2|14000120B | call <easy-crackme1.sub_140001070> |
3|140001210 | lea r8,qword ptr ss:[rsp+20]       |
3|140001215 | lea rdx,qword ptr ss:[rsp+24]      | rdx:EntryPoint
3|14000121A | lea rcx,qword ptr ds:[140002238]   | 140002238:"%d %d"
3|140001221 | call <easy-crackme1.sub_140001120> |
4|140001226 | mov edx,dword ptr ss:[rsp+20]      |
4|14000122A | mov ecx,dword ptr ss:[rsp+24]      |
4|14000122E | call <easy-crackme1.sub_140001180> |
5|140001233 | test eax,eax                       |
5|140001235 | je easy-crackme1.140001246         |
5|140001237 | lea rcx,qword ptr ds:[140002240]   | 140002240:"correct!"
5|14000123E | call qword ptr ds:[<&puts>]        |
5|140001244 | jmp easy-crackme1.140001253        |
5|140001246 | lea rcx,qword ptr ds:[14000224C]   | 14000224C:"wrong!"
5|14000124D | call qword ptr ds:[<&puts>]        |
6|140001253 | xor eax,eax                        |
6|140001255 | add rsp,38                         |
6|140001259 | ret                                |
```

**문제 풀이-3 sub_140001180분석**

디스어셈블 결과 `jmp`와 `jcc`코드가 복잡해 보이면 x64dbg의 그래프 기능 이용

**문제 풀이-4 그래프로 분석**

선의 의미를 잘 생각하며 각각 노드에 대한 분석